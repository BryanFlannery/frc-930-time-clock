package Team;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;

/**
 * Created by Admin on 9/8/2014.
 */
public class Member {

    private String fName; // first name
    private String lName; // last name
    private String ID; // unique id usually student id
    private Connection DB; // the connection to the database
    private boolean clockedIn = false;
    private boolean REGISTERED = false; // the state of the members database connection

    public Member(String ID, String fName, String lName) {
        this.fName = fName;
        this.lName = lName;
        this.ID = ID;
        //System.out.println(fName+" "+lName);
    }
    /*
    @function register - creates table if doesnt exist and formats table for unique indices
    @param database - the connection for the database usually gotten from team.getDB()
    @return false if there was an error or the db is not registered to the member, true upon successful query
     */
    public boolean register(Connection database){
        DB = database;
        if (DB != null) {
            try {
                Statement statement = DB.createStatement();
                statement.setQueryTimeout(30);
                statement.executeUpdate("CREATE TABLE IF NOT EXISTS ID_" + ID + "(id INTEGER PRIMARY KEY AUTOINCREMENT, inEpoch REAL, outEpoch REAL, type TEXT NOT NULL)");
                statement.executeUpdate("CREATE UNIQUE INDEX IF NOT EXISTS ID_"+ID+"_idx ON ID_"+ID+"(id)");
            } catch (SQLException e) {
                e.printStackTrace();
                return false;
            }
            REGISTERED = true;
            return true;
        }
        return false;
    }

    // Misc accessor/setter functions
    public String getFirstName() {
        return fName;
    }

    public String getLastName() {
        return lName;
    }

    public String getID() {
        return ID;
    }

    public boolean getClockedIn() { return clockedIn; }

    public void setClockedIn(boolean y) {
        this.clockedIn = y;
    }



    /*
    @function clockIn - creates an entry in the database for x time and x type
    @param inEpoch - Unix epoch systime in millis/1000
    @param type - what category the time should be attributed to
    @return false if there was an error or the db is not registered to the member, true upon successful query
     */
    public boolean clockIn(float inEpoch, Entry.TIME_TYPE type){
        if (REGISTERED) {
            try {
                Statement statement = DB.createStatement();
                statement.setQueryTimeout(30);
                statement.executeUpdate("INSERT INTO ID_"+ID+" VALUES(NULL, "+inEpoch+", 0, '"+type+"')");

            } catch (SQLException e) {
                e.printStackTrace();
                return false;
            }
            return true;
        }
        return false;
    }
     /*
    @function clockOut - appends the clockIn time with the given out time
    @param outEpoch - Unix epoch systime in millis/1000
    @return false if there was an error or the db is not registered to the member, true upon successful query
     */
    public boolean clockOut(float outEpoch) {
        if (REGISTERED) {
            try {
                Statement statement = DB.createStatement();
                statement.setQueryTimeout(30);
                ResultSet rs = this.getClockIn();
                if (rs.next()) {
                    statement.executeUpdate("UPDATE ID_" + ID + " SET outEpoch = " + outEpoch + " WHERE id = " + rs.getInt("id") + " AND outEpoch = 0.0");
                    rs.close();
                } else {return false;}
            } catch (SQLException e) {
                e.printStackTrace();
                return false;
            }
            return true;
        }
        return false;
    }

    /*
    @function getClockIn - gets the last entry in the member table where outEpoch was 0
    @return null if not already clocked in or the db is not registered, otherwise return the resultSet generated by the query
     */
    public ResultSet getClockIn() {
        if (REGISTERED) {
            try {
                Statement statement = DB.createStatement();
                statement.setQueryTimeout(30);
                return statement.executeQuery("SELECT * FROM ID_"+ID+" WHERE outEpoch = 0 ORDER BY id DESC LIMIT 1");
            } catch (SQLException e) {
                e.printStackTrace();
            }

        }
        return null;
    }


    /*
    @function setEntry - manually adds a clockin/clockout sequence to the table
    @param id - id of the table (index)
    @param inEpoch, outEpoch - Unix epoch systime in millis/1000
    @param type - what category the time should be attributed to
    @return false if there was an error or the db is not registered to the member, true upon successful query
     */
    public boolean setEntry(int id, float inEpoch, float outEpoch, Entry.TIME_TYPE type) {
        if (REGISTERED) {
            try {
                Statement statement = DB.createStatement();
                statement.setQueryTimeout(30);

                statement.executeUpdate("INSERT OR REPLACE INTO ID_"+ID+"(id, inEpoch, outEpoch, type) VALUES(" + id + ", " + inEpoch + " , " + outEpoch + ", '"+type+"')");
            } catch (SQLException e) {
                e.printStackTrace();
                return false;
            }
            return true;

        }
        return false;
    }

    /*
   @function removeEntry - removes a row with a specific id
   @param id - row that has id
   @return false if there was an error or the db is not registered to the member, true upon successful query
    */
    public boolean removeEntry(int id) {
        if (REGISTERED) {
            try {
                Statement statement = DB.createStatement();
                statement.setQueryTimeout(30);

                statement.executeUpdate("DELETE FROM ID_"+ID+" WHERE id = " + id);
            } catch (SQLException e) {
                e.printStackTrace();
                return false;
            }
            return true;

        }
        return false;
    }

    public ObservableList<Entry> getEntries()
    {
        ObservableList<Entry> output = FXCollections.observableArrayList();
        if (REGISTERED) {
            try {
                Statement statement = DB.createStatement();
                statement.setQueryTimeout(30);
                ResultSet rs = statement.executeQuery("SELECT * FROM ID_"+ID);

                while(rs.next()) {
                    long outEpoch = rs.getLong("outEpoch");
                    LocalDateTime in = LocalDateTime.ofEpochSecond(rs.getLong("inEpoch"), 0, ZoneOffset.ofHours(0));
                    LocalDateTime out = LocalDateTime.ofEpochSecond(outEpoch, 0, ZoneOffset.ofHours(0));
                    if (outEpoch == 0) {
                        output.add(new Entry(rs.getInt("id"), in.format(DateTimeFormatter.ISO_LOCAL_DATE),
                                in.format(DateTimeFormatter.ofPattern("hh:mm a")),
                                "N/A", rs.getString("type")));
                    } else {
                        output.add(new Entry(rs.getInt("id"), in.format(DateTimeFormatter.ISO_LOCAL_DATE),
                                in.format(DateTimeFormatter.ofPattern("hh:mm a")),
                                out.format(DateTimeFormatter.ofPattern("hh:mm a")), rs.getString("type")));
                    }
                }
                return output;

            } catch(SQLException e) {
                e.printStackTrace();
                return null;
            }
        }
        return null;
    }

}
